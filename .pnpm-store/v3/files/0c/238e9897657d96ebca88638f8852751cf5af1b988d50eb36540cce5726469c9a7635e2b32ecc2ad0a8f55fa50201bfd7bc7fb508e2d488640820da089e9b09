import { PredictiveEngine } from './core/PredictiveEngine';
import { KubernetesAutoscaler } from './services/KubernetesAutoscaler';
import { AdaptiveAgent } from './models/AdaptiveAgent';
import { BaselineLoader } from './utils/baselineLoader';
import { PerformanceMetrics, PredictiveThresholds, ScalingDecision } from './types';
import * as dotenv from 'dotenv';

// Load environment variables
dotenv.config();

export class NeonHubPredictiveEngine {
  private predictiveEngine: PredictiveEngine;
  private kubernetesAutoscaler: KubernetesAutoscaler;
  private adaptiveAgent: AdaptiveAgent;
  private isInitialized = false;

  constructor() {
    const thresholds: PredictiveThresholds = {
      trafficSpikeThreshold: parseFloat(process.env.TRAFFIC_SPIKE_THRESHOLD || '1.5'),
      latencyDegradationThreshold: parseFloat(process.env.LATENCY_DEGRADATION_THRESHOLD || '1.2'),
      errorRateThreshold: parseFloat(process.env.ERROR_RATE_THRESHOLD || '0.05'),
      conversionDropThreshold: parseFloat(process.env.CONVERSION_DROP_THRESHOLD || '0.8'),
      cpuUtilizationThreshold: parseFloat(process.env.CPU_UTILIZATION_THRESHOLD || '0.8'),
      memoryUtilizationThreshold: parseFloat(process.env.MEMORY_UTILIZATION_THRESHOLD || '0.85')
    };

    this.predictiveEngine = new PredictiveEngine(thresholds);

    const neonHubApiUrl = process.env.NEONHUB_API_URL || 'http://localhost:3001';
    const prometheusUrl = process.env.PROMETHEUS_URL || 'http://localhost:9090';

    this.kubernetesAutoscaler = new KubernetesAutoscaler(neonHubApiUrl, prometheusUrl);
    this.adaptiveAgent = new AdaptiveAgent();
  }

  async initialize(): Promise<void> {
    if (this.isInitialized) return;

    try {
      await this.predictiveEngine.initialize();
      await this.adaptiveAgent.initialize();

      this.isInitialized = true;
      console.log('NeonHub Predictive Engine v3.2 initialized successfully');
    } catch (error) {
      console.error('Failed to initialize predictive engine:', error);
      throw error;
    }
  }

  async processMetrics(currentMetrics: PerformanceMetrics): Promise<ScalingDecision> {
    if (!this.isInitialized) {
      throw new Error('Predictive engine not initialized');
    }

    // Update historical data
    this.predictiveEngine.updateHistoricalData(currentMetrics);

    // Create reinforcement learning state
    const rlState = {
      currentMetrics,
      historicalMetrics: this.predictiveEngine.getHistoricalData(),
      scalingActions: [], // This would be populated from actual scaling history
      reward: 0
    };

    // Get adaptive agent decision
    const agentDecision = this.adaptiveAgent.chooseAction(rlState);

    // Get predictive engine decision
    const predictiveDecision = await this.predictiveEngine.makeScalingDecision(currentMetrics);

    // Combine decisions (weighted average)
    const combinedDecision: ScalingDecision = {
      action: agentDecision.confidence > predictiveDecision.confidence ? agentDecision.action : predictiveDecision.action,
      targetReplicas: Math.round((agentDecision.targetReplicas * agentDecision.confidence + predictiveDecision.targetReplicas * predictiveDecision.confidence) / (agentDecision.confidence + predictiveDecision.confidence)),
      reason: `Combined decision: Agent (${agentDecision.confidence.toFixed(2)}) + Predictive (${predictiveDecision.confidence.toFixed(2)})`,
      confidence: Math.max(agentDecision.confidence, predictiveDecision.confidence),
      predictedLoad: (agentDecision.predictedLoad + predictiveDecision.predictedLoad) / 2
    };

    return combinedDecision;
  }

  async executeScaling(decision: ScalingDecision, namespace: string = 'default', deploymentName: string = 'neonhub-api'): Promise<void> {
    if (decision.action === 'no_action') {
      console.log('No scaling action required');
      return;
    }

    try {
      await this.kubernetesAutoscaler.scaleDeployment(namespace, deploymentName, decision);

      // Verify zero-downtime scaling
      const isZeroDowntime = await this.kubernetesAutoscaler.checkZeroDowntimeScaling(namespace, deploymentName);
      if (!isZeroDowntime) {
        console.warn('Zero-downtime scaling verification failed');
      }

      console.log(`Successfully executed scaling: ${decision.action} to ${decision.targetReplicas} replicas`);
    } catch (error) {
      console.error('Failed to execute scaling:', error);
      throw error;
    }
  }

  async getSystemHealth(): Promise<{
    predictiveEngine: boolean;
    kubernetesAutoscaler: boolean;
    adaptiveAgent: boolean;
    overall: boolean;
  }> {
    const health = {
      predictiveEngine: this.isInitialized,
      kubernetesAutoscaler: true, // Would implement actual health check
      adaptiveAgent: this.isInitialized,
      overall: this.isInitialized
    };

    return health;
  }

  getAdaptiveAgentStats() {
    return this.adaptiveAgent.getLearningStats();
  }

  getBaselineMetrics(): PerformanceMetrics {
    return this.predictiveEngine.getBaselineMetrics();
  }

  // Utility methods for external integration
  static async loadBaselineMetrics(): Promise<PerformanceMetrics> {
    return await BaselineLoader.loadV31Baseline();
  }

  static async validateMetrics(metrics: PerformanceMetrics): Promise<boolean> {
    return BaselineLoader.validateBaseline(metrics);
  }
}

// Export individual components for advanced usage
export {
  PredictiveEngine,
  KubernetesAutoscaler,
  AdaptiveAgent,
  BaselineLoader
};

export type {
  PerformanceMetrics,
  PredictiveThresholds,
  ScalingDecision
};

// Default export for easy importing
export default NeonHubPredictiveEngine;